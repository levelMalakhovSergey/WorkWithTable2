{"ast":null,"code":"export function sum(values, aggregatedValues) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return aggregatedValues.reduce((sum, next) => sum + (typeof next === 'number' ? next : 0), 0);\n}\nexport function min(values) {\n  let min = values[0] || 0;\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n    }\n  });\n  return min;\n}\nexport function max(values) {\n  let max = values[0] || 0;\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      max = Math.max(max, value);\n    }\n  });\n  return max;\n}\nexport function minMax(values) {\n  let min = values[0] || 0;\n  let max = values[0] || 0;\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n    }\n  });\n  return `${min}..${max}`;\n}\nexport function average(values) {\n  return sum(null, values) / values.length;\n}\nexport function median(values) {\n  if (!values.length) {\n    return null;\n  }\n\n  const mid = Math.floor(values.length / 2);\n  const nums = [...values].sort((a, b) => a - b);\n  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n}\nexport function unique(values) {\n  return Array.from(new Set(values).values());\n}\nexport function uniqueCount(values) {\n  return new Set(values).size;\n}\nexport function count(values) {\n  return values.length;\n}","map":{"version":3,"sources":["C:/Projects/TableSite/tablesite2/node_modules/react-table/src/aggregations.js"],"names":["sum","values","aggregatedValues","reduce","next","min","forEach","value","Math","max","minMax","average","length","median","mid","floor","nums","sort","a","b","unique","Array","from","Set","uniqueCount","size","count"],"mappings":"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","sourcesContent":["export function sum(values, aggregatedValues) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return aggregatedValues.reduce(\n    (sum, next) => sum + (typeof next === 'number' ? next : 0),\n    0\n  )\n}\n\nexport function min(values) {\n  let min = values[0] || 0\n\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value)\n    }\n  })\n\n  return min\n}\n\nexport function max(values) {\n  let max = values[0] || 0\n\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      max = Math.max(max, value)\n    }\n  })\n\n  return max\n}\n\nexport function minMax(values) {\n  let min = values[0] || 0\n  let max = values[0] || 0\n\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value)\n      max = Math.max(max, value)\n    }\n  })\n\n  return `${min}..${max}`\n}\n\nexport function average(values) {\n  return sum(null, values) / values.length\n}\n\nexport function median(values) {\n  if (!values.length) {\n    return null\n  }\n\n  const mid = Math.floor(values.length / 2)\n  const nums = [...values].sort((a, b) => a - b)\n  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2\n}\n\nexport function unique(values) {\n  return Array.from(new Set(values).values())\n}\n\nexport function uniqueCount(values) {\n  return new Set(values).size\n}\n\nexport function count(values) {\n  return values.length\n}\n"]},"metadata":{},"sourceType":"module"}