{"ast":null,"code":"import React from 'react';\nimport * as aggregations from '../aggregations';\nimport { getFirstDefined, flattenBy } from '../utils';\nimport { actions, makePropGetter, ensurePluginOrder, useMountedLayoutEffect, useGetLatest } from '../publicUtils';\nconst emptyArray = [];\nconst emptyObject = {}; // Actions\n\nactions.resetGroupBy = 'resetGroupBy';\nactions.setGroupBy = 'setGroupBy';\nactions.toggleGroupBy = 'toggleGroupBy';\nexport const useGroupBy = hooks => {\n  hooks.getGroupByToggleProps = [defaultGetGroupByToggleProps];\n  hooks.stateReducers.push(reducer);\n  hooks.visibleColumnsDeps.push((deps, _ref) => {\n    let {\n      instance\n    } = _ref;\n    return [...deps, instance.state.groupBy];\n  });\n  hooks.visibleColumns.push(visibleColumns);\n  hooks.useInstance.push(useInstance);\n  hooks.prepareRow.push(prepareRow);\n};\nuseGroupBy.pluginName = 'useGroupBy';\n\nconst defaultGetGroupByToggleProps = (props, _ref2) => {\n  let {\n    header\n  } = _ref2;\n  return [props, {\n    onClick: header.canGroupBy ? e => {\n      e.persist();\n      header.toggleGroupBy();\n    } : undefined,\n    style: {\n      cursor: header.canGroupBy ? 'pointer' : undefined\n    },\n    title: 'Toggle GroupBy'\n  }];\n}; // Reducer\n\n\nfunction reducer(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return {\n      groupBy: [],\n      ...state\n    };\n  }\n\n  if (action.type === actions.resetGroupBy) {\n    return { ...state,\n      groupBy: instance.initialState.groupBy || []\n    };\n  }\n\n  if (action.type === actions.setGroupBy) {\n    const {\n      value\n    } = action;\n    return { ...state,\n      groupBy: value\n    };\n  }\n\n  if (action.type === actions.toggleGroupBy) {\n    const {\n      columnId,\n      value: setGroupBy\n    } = action;\n    const resolvedGroupBy = typeof setGroupBy !== 'undefined' ? setGroupBy : !state.groupBy.includes(columnId);\n\n    if (resolvedGroupBy) {\n      return { ...state,\n        groupBy: [...state.groupBy, columnId]\n      };\n    }\n\n    return { ...state,\n      groupBy: state.groupBy.filter(d => d !== columnId)\n    };\n  }\n}\n\nfunction visibleColumns(columns, _ref3) {\n  let {\n    instance: {\n      state: {\n        groupBy\n      }\n    }\n  } = _ref3;\n  // Sort grouped columns to the start of the column list\n  // before the headers are built\n  const groupByColumns = groupBy.map(g => columns.find(col => col.id === g)).filter(Boolean);\n  const nonGroupByColumns = columns.filter(col => !groupBy.includes(col.id));\n  columns = [...groupByColumns, ...nonGroupByColumns];\n  columns.forEach(column => {\n    column.isGrouped = groupBy.includes(column.id);\n    column.groupedIndex = groupBy.indexOf(column.id);\n  });\n  return columns;\n}\n\nconst defaultUserAggregations = {};\n\nfunction useInstance(instance) {\n  const {\n    data,\n    rows,\n    flatRows,\n    rowsById,\n    allColumns,\n    flatHeaders,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    aggregations: userAggregations = defaultUserAggregations,\n    plugins,\n    state: {\n      groupBy\n    },\n    dispatch,\n    autoResetGroupBy = true,\n    disableGroupBy,\n    defaultCanGroupBy,\n    getHooks\n  } = instance;\n  ensurePluginOrder(plugins, ['useColumnOrder', 'useFilters'], 'useGroupBy');\n  const getInstance = useGetLatest(instance);\n  allColumns.forEach(column => {\n    const {\n      accessor,\n      defaultGroupBy: defaultColumnGroupBy,\n      disableGroupBy: columnDisableGroupBy\n    } = column;\n    column.canGroupBy = accessor ? getFirstDefined(column.canGroupBy, columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(column.canGroupBy, defaultColumnGroupBy, defaultCanGroupBy, false);\n\n    if (column.canGroupBy) {\n      column.toggleGroupBy = () => instance.toggleGroupBy(column.id);\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell;\n  });\n  const toggleGroupBy = React.useCallback((columnId, value) => {\n    dispatch({\n      type: actions.toggleGroupBy,\n      columnId,\n      value\n    });\n  }, [dispatch]);\n  const setGroupBy = React.useCallback(value => {\n    dispatch({\n      type: actions.setGroupBy,\n      value\n    });\n  }, [dispatch]);\n  flatHeaders.forEach(header => {\n    header.getGroupByToggleProps = makePropGetter(getHooks().getGroupByToggleProps, {\n      instance: getInstance(),\n      header\n    });\n  });\n  const [groupedRows, groupedFlatRows, groupedRowsById, onlyGroupedFlatRows, onlyGroupedRowsById, nonGroupedFlatRows, nonGroupedRowsById] = React.useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return [rows, flatRows, rowsById, emptyArray, emptyObject, flatRows, rowsById];\n    } // Ensure that the list of filtered columns exist\n\n\n    const existingGroupBy = groupBy.filter(g => allColumns.find(col => col.id === g)); // Find the columns that can or are aggregating\n    // Uses each column to aggregate rows into a single value\n\n    const aggregateRowsToValues = (leafRows, groupedRows, depth) => {\n      const values = {};\n      allColumns.forEach(column => {\n        // Don't aggregate columns that are in the groupBy\n        if (existingGroupBy.includes(column.id)) {\n          values[column.id] = groupedRows[0] ? groupedRows[0].values[column.id] : null;\n          return;\n        } // Aggregate the values\n\n\n        let aggregateFn = typeof column.aggregate === 'function' ? column.aggregate : userAggregations[column.aggregate] || aggregations[column.aggregate];\n\n        if (aggregateFn) {\n          // Get the columnValues to aggregate\n          const groupedValues = groupedRows.map(row => row.values[column.id]); // Get the columnValues to aggregate\n\n          const leafValues = leafRows.map(row => {\n            let columnValue = row.values[column.id];\n\n            if (!depth && column.aggregateValue) {\n              const aggregateValueFn = typeof column.aggregateValue === 'function' ? column.aggregateValue : userAggregations[column.aggregateValue] || aggregations[column.aggregateValue];\n\n              if (!aggregateValueFn) {\n                console.info({\n                  column\n                });\n                throw new Error(`React Table: Invalid column.aggregateValue option for column listed above`);\n              }\n\n              columnValue = aggregateValueFn(columnValue, row, column);\n            }\n\n            return columnValue;\n          });\n          values[column.id] = aggregateFn(leafValues, groupedValues);\n        } else if (column.aggregate) {\n          console.info({\n            column\n          });\n          throw new Error(`React Table: Invalid column.aggregate option for column listed above`);\n        } else {\n          values[column.id] = null;\n        }\n      });\n      return values;\n    };\n\n    let groupedFlatRows = [];\n    const groupedRowsById = {};\n    const onlyGroupedFlatRows = [];\n    const onlyGroupedRowsById = {};\n    const nonGroupedFlatRows = [];\n    const nonGroupedRowsById = {}; // Recursively group the data\n\n    const groupUpRecursively = function (rows) {\n      let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let parentId = arguments.length > 2 ? arguments[2] : undefined;\n\n      // This is the last level, just return the rows\n      if (depth === existingGroupBy.length) {\n        return rows;\n      }\n\n      const columnId = existingGroupBy[depth]; // Group the rows together for this level\n\n      let rowGroupsMap = groupByFn(rows, columnId); // Peform aggregations for each group\n\n      const aggregatedGroupedRows = Object.entries(rowGroupsMap).map((_ref4, index) => {\n        let [groupByVal, groupedRows] = _ref4;\n        let id = `${columnId}:${groupByVal}`;\n        id = parentId ? `${parentId}>${id}` : id; // First, Recurse to group sub rows before aggregation\n\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n\n        const leafRows = depth ? flattenBy(groupedRows, 'leafRows') : groupedRows;\n        const values = aggregateRowsToValues(leafRows, groupedRows, depth);\n        const row = {\n          id,\n          isGrouped: true,\n          groupByID: columnId,\n          groupByVal,\n          values,\n          subRows,\n          leafRows,\n          depth,\n          index\n        };\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow;\n\n          if (subRow.isGrouped) {\n            onlyGroupedFlatRows.push(subRow);\n            onlyGroupedRowsById[subRow.id] = subRow;\n          } else {\n            nonGroupedFlatRows.push(subRow);\n            nonGroupedRowsById[subRow.id] = subRow;\n          }\n        });\n        return row;\n      });\n      return aggregatedGroupedRows;\n    };\n\n    const groupedRows = groupUpRecursively(rows);\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow;\n\n      if (subRow.isGrouped) {\n        onlyGroupedFlatRows.push(subRow);\n        onlyGroupedRowsById[subRow.id] = subRow;\n      } else {\n        nonGroupedFlatRows.push(subRow);\n        nonGroupedRowsById[subRow.id] = subRow;\n      }\n    }); // Assign the new data\n\n    return [groupedRows, groupedFlatRows, groupedRowsById, onlyGroupedFlatRows, onlyGroupedRowsById, nonGroupedFlatRows, nonGroupedRowsById];\n  }, [manualGroupBy, groupBy, rows, flatRows, rowsById, allColumns, userAggregations, groupByFn]);\n  const getAutoResetGroupBy = useGetLatest(autoResetGroupBy);\n  useMountedLayoutEffect(() => {\n    if (getAutoResetGroupBy()) {\n      dispatch({\n        type: actions.resetGroupBy\n      });\n    }\n  }, [dispatch, manualGroupBy ? null : data]);\n  Object.assign(instance, {\n    preGroupedRows: rows,\n    preGroupedFlatRow: flatRows,\n    preGroupedRowsById: rowsById,\n    groupedRows,\n    groupedFlatRows,\n    groupedRowsById,\n    onlyGroupedFlatRows,\n    onlyGroupedRowsById,\n    nonGroupedFlatRows,\n    nonGroupedRowsById,\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n    toggleGroupBy,\n    setGroupBy\n  });\n}\n\nfunction prepareRow(row) {\n  row.allCells.forEach(cell => {\n    // Grouped cells are in the groupBy and the pivot cell for the row\n    cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Placeholder cells are any columns in the groupBy that are not grouped\n\n    cell.isPlaceholder = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows\n\n    cell.isAggregated = !cell.isGrouped && !cell.isPlaceholder && row.subRows?.length;\n  });\n}\n\nexport function defaultGroupByFn(rows, columnId) {\n  return rows.reduce((prev, row, i) => {\n    // TODO: Might want to implement a key serializer here so\n    // irregular column values can still be grouped if needed?\n    const resKey = `${row.values[columnId]}`;\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];\n    prev[resKey].push(row);\n    return prev;\n  }, {});\n}","map":{"version":3,"sources":["C:/Projects/TableSite/tablesite2/node_modules/react-table/src/plugin-hooks/useGroupBy.js"],"names":["React","aggregations","getFirstDefined","flattenBy","actions","makePropGetter","ensurePluginOrder","useMountedLayoutEffect","useGetLatest","emptyArray","emptyObject","resetGroupBy","setGroupBy","toggleGroupBy","useGroupBy","hooks","getGroupByToggleProps","defaultGetGroupByToggleProps","stateReducers","push","reducer","visibleColumnsDeps","deps","instance","state","groupBy","visibleColumns","useInstance","prepareRow","pluginName","props","header","onClick","canGroupBy","e","persist","undefined","style","cursor","title","action","previousState","type","init","initialState","value","columnId","resolvedGroupBy","includes","filter","d","columns","groupByColumns","map","g","find","col","id","Boolean","nonGroupByColumns","forEach","column","isGrouped","groupedIndex","indexOf","defaultUserAggregations","data","rows","flatRows","rowsById","allColumns","flatHeaders","groupByFn","defaultGroupByFn","manualGroupBy","userAggregations","plugins","dispatch","autoResetGroupBy","disableGroupBy","defaultCanGroupBy","getHooks","getInstance","accessor","defaultGroupBy","defaultColumnGroupBy","columnDisableGroupBy","Aggregated","Cell","useCallback","groupedRows","groupedFlatRows","groupedRowsById","onlyGroupedFlatRows","onlyGroupedRowsById","nonGroupedFlatRows","nonGroupedRowsById","useMemo","length","existingGroupBy","aggregateRowsToValues","leafRows","depth","values","aggregateFn","aggregate","groupedValues","row","leafValues","columnValue","aggregateValue","aggregateValueFn","console","info","Error","groupUpRecursively","parentId","rowGroupsMap","aggregatedGroupedRows","Object","entries","index","groupByVal","subRows","groupByID","subRow","getAutoResetGroupBy","assign","preGroupedRows","preGroupedFlatRow","preGroupedRowsById","allCells","cell","isPlaceholder","isAggregated","reduce","prev","i","resKey","Array","isArray"],"mappings":"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","sourcesContent":["import React from 'react'\n\nimport * as aggregations from '../aggregations'\n\nimport { getFirstDefined, flattenBy } from '../utils'\n\nimport {\n  actions,\n  makePropGetter,\n  ensurePluginOrder,\n  useMountedLayoutEffect,\n  useGetLatest,\n} from '../publicUtils'\n\nconst emptyArray = []\nconst emptyObject = {}\n\n// Actions\nactions.resetGroupBy = 'resetGroupBy'\nactions.setGroupBy = 'setGroupBy'\nactions.toggleGroupBy = 'toggleGroupBy'\n\nexport const useGroupBy = hooks => {\n  hooks.getGroupByToggleProps = [defaultGetGroupByToggleProps]\n  hooks.stateReducers.push(reducer)\n  hooks.visibleColumnsDeps.push((deps, { instance }) => [\n    ...deps,\n    instance.state.groupBy,\n  ])\n  hooks.visibleColumns.push(visibleColumns)\n  hooks.useInstance.push(useInstance)\n  hooks.prepareRow.push(prepareRow)\n}\n\nuseGroupBy.pluginName = 'useGroupBy'\n\nconst defaultGetGroupByToggleProps = (props, { header }) => [\n  props,\n  {\n    onClick: header.canGroupBy\n      ? e => {\n          e.persist()\n          header.toggleGroupBy()\n        }\n      : undefined,\n    style: {\n      cursor: header.canGroupBy ? 'pointer' : undefined,\n    },\n    title: 'Toggle GroupBy',\n  },\n]\n\n// Reducer\nfunction reducer(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return {\n      groupBy: [],\n      ...state,\n    }\n  }\n\n  if (action.type === actions.resetGroupBy) {\n    return {\n      ...state,\n      groupBy: instance.initialState.groupBy || [],\n    }\n  }\n\n  if (action.type === actions.setGroupBy) {\n    const { value } = action\n    return {\n      ...state,\n      groupBy: value,\n    }\n  }\n\n  if (action.type === actions.toggleGroupBy) {\n    const { columnId, value: setGroupBy } = action\n\n    const resolvedGroupBy =\n      typeof setGroupBy !== 'undefined'\n        ? setGroupBy\n        : !state.groupBy.includes(columnId)\n\n    if (resolvedGroupBy) {\n      return {\n        ...state,\n        groupBy: [...state.groupBy, columnId],\n      }\n    }\n\n    return {\n      ...state,\n      groupBy: state.groupBy.filter(d => d !== columnId),\n    }\n  }\n}\n\nfunction visibleColumns(\n  columns,\n  {\n    instance: {\n      state: { groupBy },\n    },\n  }\n) {\n  // Sort grouped columns to the start of the column list\n  // before the headers are built\n\n  const groupByColumns = groupBy\n    .map(g => columns.find(col => col.id === g))\n    .filter(Boolean)\n\n  const nonGroupByColumns = columns.filter(col => !groupBy.includes(col.id))\n\n  columns = [...groupByColumns, ...nonGroupByColumns]\n\n  columns.forEach(column => {\n    column.isGrouped = groupBy.includes(column.id)\n    column.groupedIndex = groupBy.indexOf(column.id)\n  })\n\n  return columns\n}\n\nconst defaultUserAggregations = {}\n\nfunction useInstance(instance) {\n  const {\n    data,\n    rows,\n    flatRows,\n    rowsById,\n    allColumns,\n    flatHeaders,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    aggregations: userAggregations = defaultUserAggregations,\n    plugins,\n    state: { groupBy },\n    dispatch,\n    autoResetGroupBy = true,\n    disableGroupBy,\n    defaultCanGroupBy,\n    getHooks,\n  } = instance\n\n  ensurePluginOrder(plugins, ['useColumnOrder', 'useFilters'], 'useGroupBy')\n\n  const getInstance = useGetLatest(instance)\n\n  allColumns.forEach(column => {\n    const {\n      accessor,\n      defaultGroupBy: defaultColumnGroupBy,\n      disableGroupBy: columnDisableGroupBy,\n    } = column\n\n    column.canGroupBy = accessor\n      ? getFirstDefined(\n          column.canGroupBy,\n          columnDisableGroupBy === true ? false : undefined,\n          disableGroupBy === true ? false : undefined,\n          true\n        )\n      : getFirstDefined(\n          column.canGroupBy,\n          defaultColumnGroupBy,\n          defaultCanGroupBy,\n          false\n        )\n\n    if (column.canGroupBy) {\n      column.toggleGroupBy = () => instance.toggleGroupBy(column.id)\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell\n  })\n\n  const toggleGroupBy = React.useCallback(\n    (columnId, value) => {\n      dispatch({ type: actions.toggleGroupBy, columnId, value })\n    },\n    [dispatch]\n  )\n\n  const setGroupBy = React.useCallback(\n    value => {\n      dispatch({ type: actions.setGroupBy, value })\n    },\n    [dispatch]\n  )\n\n  flatHeaders.forEach(header => {\n    header.getGroupByToggleProps = makePropGetter(\n      getHooks().getGroupByToggleProps,\n      { instance: getInstance(), header }\n    )\n  })\n\n  const [\n    groupedRows,\n    groupedFlatRows,\n    groupedRowsById,\n    onlyGroupedFlatRows,\n    onlyGroupedRowsById,\n    nonGroupedFlatRows,\n    nonGroupedRowsById,\n  ] = React.useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return [\n        rows,\n        flatRows,\n        rowsById,\n        emptyArray,\n        emptyObject,\n        flatRows,\n        rowsById,\n      ]\n    }\n\n    // Ensure that the list of filtered columns exist\n    const existingGroupBy = groupBy.filter(g =>\n      allColumns.find(col => col.id === g)\n    )\n\n    // Find the columns that can or are aggregating\n    // Uses each column to aggregate rows into a single value\n    const aggregateRowsToValues = (leafRows, groupedRows, depth) => {\n      const values = {}\n\n      allColumns.forEach(column => {\n        // Don't aggregate columns that are in the groupBy\n        if (existingGroupBy.includes(column.id)) {\n          values[column.id] = groupedRows[0]\n            ? groupedRows[0].values[column.id]\n            : null\n          return\n        }\n\n        // Aggregate the values\n        let aggregateFn =\n          typeof column.aggregate === 'function'\n            ? column.aggregate\n            : userAggregations[column.aggregate] ||\n              aggregations[column.aggregate]\n\n        if (aggregateFn) {\n          // Get the columnValues to aggregate\n          const groupedValues = groupedRows.map(row => row.values[column.id])\n\n          // Get the columnValues to aggregate\n          const leafValues = leafRows.map(row => {\n            let columnValue = row.values[column.id]\n\n            if (!depth && column.aggregateValue) {\n              const aggregateValueFn =\n                typeof column.aggregateValue === 'function'\n                  ? column.aggregateValue\n                  : userAggregations[column.aggregateValue] ||\n                    aggregations[column.aggregateValue]\n\n              if (!aggregateValueFn) {\n                console.info({ column })\n                throw new Error(\n                  `React Table: Invalid column.aggregateValue option for column listed above`\n                )\n              }\n\n              columnValue = aggregateValueFn(columnValue, row, column)\n            }\n            return columnValue\n          })\n\n          values[column.id] = aggregateFn(leafValues, groupedValues)\n        } else if (column.aggregate) {\n          console.info({ column })\n          throw new Error(\n            `React Table: Invalid column.aggregate option for column listed above`\n          )\n        } else {\n          values[column.id] = null\n        }\n      })\n\n      return values\n    }\n\n    let groupedFlatRows = []\n    const groupedRowsById = {}\n    const onlyGroupedFlatRows = []\n    const onlyGroupedRowsById = {}\n    const nonGroupedFlatRows = []\n    const nonGroupedRowsById = {}\n\n    // Recursively group the data\n    const groupUpRecursively = (rows, depth = 0, parentId) => {\n      // This is the last level, just return the rows\n      if (depth === existingGroupBy.length) {\n        return rows\n      }\n\n      const columnId = existingGroupBy[depth]\n\n      // Group the rows together for this level\n      let rowGroupsMap = groupByFn(rows, columnId)\n\n      // Peform aggregations for each group\n      const aggregatedGroupedRows = Object.entries(rowGroupsMap).map(\n        ([groupByVal, groupedRows], index) => {\n          let id = `${columnId}:${groupByVal}`\n          id = parentId ? `${parentId}>${id}` : id\n\n          // First, Recurse to group sub rows before aggregation\n          const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n          // Flatten the leaf rows of the rows in this group\n          const leafRows = depth\n            ? flattenBy(groupedRows, 'leafRows')\n            : groupedRows\n\n          const values = aggregateRowsToValues(leafRows, groupedRows, depth)\n\n          const row = {\n            id,\n            isGrouped: true,\n            groupByID: columnId,\n            groupByVal,\n            values,\n            subRows,\n            leafRows,\n            depth,\n            index,\n          }\n\n          subRows.forEach(subRow => {\n            groupedFlatRows.push(subRow)\n            groupedRowsById[subRow.id] = subRow\n            if (subRow.isGrouped) {\n              onlyGroupedFlatRows.push(subRow)\n              onlyGroupedRowsById[subRow.id] = subRow\n            } else {\n              nonGroupedFlatRows.push(subRow)\n              nonGroupedRowsById[subRow.id] = subRow\n            }\n          })\n\n          return row\n        }\n      )\n\n      return aggregatedGroupedRows\n    }\n\n    const groupedRows = groupUpRecursively(rows)\n\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow)\n      groupedRowsById[subRow.id] = subRow\n      if (subRow.isGrouped) {\n        onlyGroupedFlatRows.push(subRow)\n        onlyGroupedRowsById[subRow.id] = subRow\n      } else {\n        nonGroupedFlatRows.push(subRow)\n        nonGroupedRowsById[subRow.id] = subRow\n      }\n    })\n\n    // Assign the new data\n    return [\n      groupedRows,\n      groupedFlatRows,\n      groupedRowsById,\n      onlyGroupedFlatRows,\n      onlyGroupedRowsById,\n      nonGroupedFlatRows,\n      nonGroupedRowsById,\n    ]\n  }, [\n    manualGroupBy,\n    groupBy,\n    rows,\n    flatRows,\n    rowsById,\n    allColumns,\n    userAggregations,\n    groupByFn,\n  ])\n\n  const getAutoResetGroupBy = useGetLatest(autoResetGroupBy)\n\n  useMountedLayoutEffect(() => {\n    if (getAutoResetGroupBy()) {\n      dispatch({ type: actions.resetGroupBy })\n    }\n  }, [dispatch, manualGroupBy ? null : data])\n\n  Object.assign(instance, {\n    preGroupedRows: rows,\n    preGroupedFlatRow: flatRows,\n    preGroupedRowsById: rowsById,\n    groupedRows,\n    groupedFlatRows,\n    groupedRowsById,\n    onlyGroupedFlatRows,\n    onlyGroupedRowsById,\n    nonGroupedFlatRows,\n    nonGroupedRowsById,\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n    toggleGroupBy,\n    setGroupBy,\n  })\n}\n\nfunction prepareRow(row) {\n  row.allCells.forEach(cell => {\n    // Grouped cells are in the groupBy and the pivot cell for the row\n    cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID\n    // Placeholder cells are any columns in the groupBy that are not grouped\n    cell.isPlaceholder = !cell.isGrouped && cell.column.isGrouped\n    // Aggregated cells are not grouped, not repeated, but still have subRows\n    cell.isAggregated =\n      !cell.isGrouped && !cell.isPlaceholder && row.subRows?.length\n  })\n}\n\nexport function defaultGroupByFn(rows, columnId) {\n  return rows.reduce((prev, row, i) => {\n    // TODO: Might want to implement a key serializer here so\n    // irregular column values can still be grouped if needed?\n    const resKey = `${row.values[columnId]}`\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\n    prev[resKey].push(row)\n    return prev\n  }, {})\n}\n"]},"metadata":{},"sourceType":"module"}