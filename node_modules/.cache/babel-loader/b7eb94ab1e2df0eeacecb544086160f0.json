{"ast":null,"code":"import React from 'react';\nimport { getFirstDefined, getFilterMethod, shouldAutoRemoveFilter } from '../utils';\nimport { actions, useGetLatest, functionalUpdate, useMountedLayoutEffect } from '../publicUtils';\nimport * as filterTypes from '../filterTypes'; // Actions\n\nactions.resetFilters = 'resetFilters';\nactions.setFilter = 'setFilter';\nactions.setAllFilters = 'setAllFilters';\nexport const useFilters = hooks => {\n  hooks.stateReducers.push(reducer);\n  hooks.useInstance.push(useInstance);\n};\nuseFilters.pluginName = 'useFilters';\n\nfunction reducer(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return {\n      filters: [],\n      ...state\n    };\n  }\n\n  if (action.type === actions.resetFilters) {\n    return { ...state,\n      filters: instance.initialState.filters || []\n    };\n  }\n\n  if (action.type === actions.setFilter) {\n    const {\n      columnId,\n      filterValue\n    } = action;\n    const {\n      allColumns,\n      filterTypes: userFilterTypes\n    } = instance;\n    const column = allColumns.find(d => d.id === columnId);\n\n    if (!column) {\n      throw new Error(`React-Table: Could not find a column with id: ${columnId}`);\n    }\n\n    const filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n    const previousfilter = state.filters.find(d => d.id === columnId);\n    const newFilter = functionalUpdate(filterValue, previousfilter && previousfilter.value); //\n\n    if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter, column)) {\n      return { ...state,\n        filters: state.filters.filter(d => d.id !== columnId)\n      };\n    }\n\n    if (previousfilter) {\n      return { ...state,\n        filters: state.filters.map(d => {\n          if (d.id === columnId) {\n            return {\n              id: columnId,\n              value: newFilter\n            };\n          }\n\n          return d;\n        })\n      };\n    }\n\n    return { ...state,\n      filters: [...state.filters, {\n        id: columnId,\n        value: newFilter\n      }]\n    };\n  }\n\n  if (action.type === actions.setAllFilters) {\n    const {\n      filters\n    } = action;\n    const {\n      allColumns,\n      filterTypes: userFilterTypes\n    } = instance;\n    return { ...state,\n      // Filter out undefined values\n      filters: functionalUpdate(filters, state.filters).filter(filter => {\n        const column = allColumns.find(d => d.id === filter.id);\n        const filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n        if (shouldAutoRemoveFilter(filterMethod.autoRemove, filter.value, column)) {\n          return false;\n        }\n\n        return true;\n      })\n    };\n  }\n}\n\nfunction useInstance(instance) {\n  const {\n    data,\n    rows,\n    flatRows,\n    rowsById,\n    allColumns,\n    filterTypes: userFilterTypes,\n    manualFilters,\n    defaultCanFilter = false,\n    disableFilters,\n    state: {\n      filters\n    },\n    dispatch,\n    autoResetFilters = true\n  } = instance;\n  const setFilter = React.useCallback((columnId, filterValue) => {\n    dispatch({\n      type: actions.setFilter,\n      columnId,\n      filterValue\n    });\n  }, [dispatch]);\n  const setAllFilters = React.useCallback(filters => {\n    dispatch({\n      type: actions.setAllFilters,\n      filters\n    });\n  }, [dispatch]);\n  allColumns.forEach(column => {\n    const {\n      id,\n      accessor,\n      defaultCanFilter: columnDefaultCanFilter,\n      disableFilters: columnDisableFilters\n    } = column; // Determine if a column is filterable\n\n    column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value\n\n    column.setFilter = val => setFilter(column.id, val); // Provide the current filter value to the column for\n    // convenience\n\n\n    const found = filters.find(d => d.id === id);\n    column.filterValue = found && found.value;\n  });\n  const [filteredRows, filteredFlatRows, filteredRowsById] = React.useMemo(() => {\n    if (manualFilters || !filters.length) {\n      return [rows, flatRows, rowsById];\n    }\n\n    const filteredFlatRows = [];\n    const filteredRowsById = {}; // Filters top level and nested rows\n\n    const filterRows = function (rows) {\n      let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let filteredRows = rows;\n      filteredRows = filters.reduce((filteredSoFar, _ref) => {\n        let {\n          id: columnId,\n          value: filterValue\n        } = _ref;\n        // Find the filters column\n        const column = allColumns.find(d => d.id === columnId);\n\n        if (!column) {\n          return filteredSoFar;\n        }\n\n        if (depth === 0) {\n          column.preFilteredRows = filteredSoFar;\n        }\n\n        const filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n        if (!filterMethod) {\n          console.warn(`Could not find a valid 'column.filter' for column with the ID: ${column.id}.`);\n          return filteredSoFar;\n        } // Pass the rows, id, filterValue and column to the filterMethod\n        // to get the filtered rows back\n\n\n        column.filteredRows = filterMethod(filteredSoFar, [columnId], filterValue);\n        return column.filteredRows;\n      }, rows); // Apply the filter to any subRows\n      // We technically could do this recursively in the above loop,\n      // but that would severely hinder the API for the user, since they\n      // would be required to do that recursion in some scenarios\n\n      filteredRows.forEach(row => {\n        filteredFlatRows.push(row);\n        filteredRowsById[row.id] = row;\n\n        if (!row.subRows) {\n          return;\n        }\n\n        row.subRows = row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows;\n      });\n      return filteredRows;\n    };\n\n    return [filterRows(rows), filteredFlatRows, filteredRowsById];\n  }, [manualFilters, filters, rows, flatRows, rowsById, allColumns, userFilterTypes]);\n  React.useMemo(() => {\n    // Now that each filtered column has it's partially filtered rows,\n    // lets assign the final filtered rows to all of the other columns\n    const nonFilteredColumns = allColumns.filter(column => !filters.find(d => d.id === column.id)); // This essentially enables faceted filter options to be built easily\n    // using every column's preFilteredRows value\n\n    nonFilteredColumns.forEach(column => {\n      column.preFilteredRows = filteredRows;\n      column.filteredRows = filteredRows;\n    });\n  }, [filteredRows, filters, allColumns]);\n  const getAutoResetFilters = useGetLatest(autoResetFilters);\n  useMountedLayoutEffect(() => {\n    if (getAutoResetFilters()) {\n      dispatch({\n        type: actions.resetFilters\n      });\n    }\n  }, [dispatch, manualFilters ? null : data]);\n  Object.assign(instance, {\n    preFilteredRows: rows,\n    preFilteredFlatRows: flatRows,\n    preFilteredRowsById: rowsById,\n    filteredRows,\n    filteredFlatRows,\n    filteredRowsById,\n    rows: filteredRows,\n    flatRows: filteredFlatRows,\n    rowsById: filteredRowsById,\n    setFilter,\n    setAllFilters\n  });\n}","map":{"version":3,"sources":["C:/Projects/TableSite/tablesite2/node_modules/react-table/src/plugin-hooks/useFilters.js"],"names":["React","getFirstDefined","getFilterMethod","shouldAutoRemoveFilter","actions","useGetLatest","functionalUpdate","useMountedLayoutEffect","filterTypes","resetFilters","setFilter","setAllFilters","useFilters","hooks","stateReducers","push","reducer","useInstance","pluginName","state","action","previousState","instance","type","init","filters","initialState","columnId","filterValue","allColumns","userFilterTypes","column","find","d","id","Error","filterMethod","filter","previousfilter","newFilter","value","autoRemove","map","data","rows","flatRows","rowsById","manualFilters","defaultCanFilter","disableFilters","dispatch","autoResetFilters","useCallback","forEach","accessor","columnDefaultCanFilter","columnDisableFilters","canFilter","undefined","val","found","filteredRows","filteredFlatRows","filteredRowsById","useMemo","length","filterRows","depth","reduce","filteredSoFar","preFilteredRows","console","warn","row","subRows","nonFilteredColumns","getAutoResetFilters","Object","assign","preFilteredFlatRows","preFilteredRowsById"],"mappings":"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","sourcesContent":["import React from 'react'\n\nimport {\n  getFirstDefined,\n  getFilterMethod,\n  shouldAutoRemoveFilter,\n} from '../utils'\n\nimport {\n  actions,\n  useGetLatest,\n  functionalUpdate,\n  useMountedLayoutEffect,\n} from '../publicUtils'\n\nimport * as filterTypes from '../filterTypes'\n\n// Actions\nactions.resetFilters = 'resetFilters'\nactions.setFilter = 'setFilter'\nactions.setAllFilters = 'setAllFilters'\n\nexport const useFilters = hooks => {\n  hooks.stateReducers.push(reducer)\n  hooks.useInstance.push(useInstance)\n}\n\nuseFilters.pluginName = 'useFilters'\n\nfunction reducer(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return {\n      filters: [],\n      ...state,\n    }\n  }\n\n  if (action.type === actions.resetFilters) {\n    return {\n      ...state,\n      filters: instance.initialState.filters || [],\n    }\n  }\n\n  if (action.type === actions.setFilter) {\n    const { columnId, filterValue } = action\n    const { allColumns, filterTypes: userFilterTypes } = instance\n\n    const column = allColumns.find(d => d.id === columnId)\n\n    if (!column) {\n      throw new Error(\n        `React-Table: Could not find a column with id: ${columnId}`\n      )\n    }\n\n    const filterMethod = getFilterMethod(\n      column.filter,\n      userFilterTypes || {},\n      filterTypes\n    )\n\n    const previousfilter = state.filters.find(d => d.id === columnId)\n\n    const newFilter = functionalUpdate(\n      filterValue,\n      previousfilter && previousfilter.value\n    )\n\n    //\n    if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter, column)) {\n      return {\n        ...state,\n        filters: state.filters.filter(d => d.id !== columnId),\n      }\n    }\n\n    if (previousfilter) {\n      return {\n        ...state,\n        filters: state.filters.map(d => {\n          if (d.id === columnId) {\n            return { id: columnId, value: newFilter }\n          }\n          return d\n        }),\n      }\n    }\n\n    return {\n      ...state,\n      filters: [...state.filters, { id: columnId, value: newFilter }],\n    }\n  }\n\n  if (action.type === actions.setAllFilters) {\n    const { filters } = action\n    const { allColumns, filterTypes: userFilterTypes } = instance\n\n    return {\n      ...state,\n      // Filter out undefined values\n      filters: functionalUpdate(filters, state.filters).filter(filter => {\n        const column = allColumns.find(d => d.id === filter.id)\n        const filterMethod = getFilterMethod(\n          column.filter,\n          userFilterTypes || {},\n          filterTypes\n        )\n\n        if (\n          shouldAutoRemoveFilter(filterMethod.autoRemove, filter.value, column)\n        ) {\n          return false\n        }\n        return true\n      }),\n    }\n  }\n}\n\nfunction useInstance(instance) {\n  const {\n    data,\n    rows,\n    flatRows,\n    rowsById,\n    allColumns,\n    filterTypes: userFilterTypes,\n    manualFilters,\n    defaultCanFilter = false,\n    disableFilters,\n    state: { filters },\n    dispatch,\n    autoResetFilters = true,\n  } = instance\n\n  const setFilter = React.useCallback(\n    (columnId, filterValue) => {\n      dispatch({ type: actions.setFilter, columnId, filterValue })\n    },\n    [dispatch]\n  )\n\n  const setAllFilters = React.useCallback(\n    filters => {\n      dispatch({\n        type: actions.setAllFilters,\n        filters,\n      })\n    },\n    [dispatch]\n  )\n\n  allColumns.forEach(column => {\n    const {\n      id,\n      accessor,\n      defaultCanFilter: columnDefaultCanFilter,\n      disableFilters: columnDisableFilters,\n    } = column\n\n    // Determine if a column is filterable\n    column.canFilter = accessor\n      ? getFirstDefined(\n          columnDisableFilters === true ? false : undefined,\n          disableFilters === true ? false : undefined,\n          true\n        )\n      : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false)\n\n    // Provide the column a way of updating the filter value\n    column.setFilter = val => setFilter(column.id, val)\n\n    // Provide the current filter value to the column for\n    // convenience\n    const found = filters.find(d => d.id === id)\n    column.filterValue = found && found.value\n  })\n\n  const [\n    filteredRows,\n    filteredFlatRows,\n    filteredRowsById,\n  ] = React.useMemo(() => {\n    if (manualFilters || !filters.length) {\n      return [rows, flatRows, rowsById]\n    }\n\n    const filteredFlatRows = []\n    const filteredRowsById = {}\n\n    // Filters top level and nested rows\n    const filterRows = (rows, depth = 0) => {\n      let filteredRows = rows\n\n      filteredRows = filters.reduce(\n        (filteredSoFar, { id: columnId, value: filterValue }) => {\n          // Find the filters column\n          const column = allColumns.find(d => d.id === columnId)\n\n          if (!column) {\n            return filteredSoFar\n          }\n\n          if (depth === 0) {\n            column.preFilteredRows = filteredSoFar\n          }\n\n          const filterMethod = getFilterMethod(\n            column.filter,\n            userFilterTypes || {},\n            filterTypes\n          )\n\n          if (!filterMethod) {\n            console.warn(\n              `Could not find a valid 'column.filter' for column with the ID: ${column.id}.`\n            )\n            return filteredSoFar\n          }\n\n          // Pass the rows, id, filterValue and column to the filterMethod\n          // to get the filtered rows back\n          column.filteredRows = filterMethod(\n            filteredSoFar,\n            [columnId],\n            filterValue\n          )\n\n          return column.filteredRows\n        },\n        rows\n      )\n\n      // Apply the filter to any subRows\n      // We technically could do this recursively in the above loop,\n      // but that would severely hinder the API for the user, since they\n      // would be required to do that recursion in some scenarios\n      filteredRows.forEach(row => {\n        filteredFlatRows.push(row)\n        filteredRowsById[row.id] = row\n        if (!row.subRows) {\n          return\n        }\n\n        row.subRows =\n          row.subRows && row.subRows.length > 0\n            ? filterRows(row.subRows, depth + 1)\n            : row.subRows\n      })\n\n      return filteredRows\n    }\n\n    return [filterRows(rows), filteredFlatRows, filteredRowsById]\n  }, [\n    manualFilters,\n    filters,\n    rows,\n    flatRows,\n    rowsById,\n    allColumns,\n    userFilterTypes,\n  ])\n\n  React.useMemo(() => {\n    // Now that each filtered column has it's partially filtered rows,\n    // lets assign the final filtered rows to all of the other columns\n    const nonFilteredColumns = allColumns.filter(\n      column => !filters.find(d => d.id === column.id)\n    )\n\n    // This essentially enables faceted filter options to be built easily\n    // using every column's preFilteredRows value\n    nonFilteredColumns.forEach(column => {\n      column.preFilteredRows = filteredRows\n      column.filteredRows = filteredRows\n    })\n  }, [filteredRows, filters, allColumns])\n\n  const getAutoResetFilters = useGetLatest(autoResetFilters)\n\n  useMountedLayoutEffect(() => {\n    if (getAutoResetFilters()) {\n      dispatch({ type: actions.resetFilters })\n    }\n  }, [dispatch, manualFilters ? null : data])\n\n  Object.assign(instance, {\n    preFilteredRows: rows,\n    preFilteredFlatRows: flatRows,\n    preFilteredRowsById: rowsById,\n    filteredRows,\n    filteredFlatRows,\n    filteredRowsById,\n    rows: filteredRows,\n    flatRows: filteredFlatRows,\n    rowsById: filteredRowsById,\n    setFilter,\n    setAllFilters,\n  })\n}\n"]},"metadata":{},"sourceType":"module"}