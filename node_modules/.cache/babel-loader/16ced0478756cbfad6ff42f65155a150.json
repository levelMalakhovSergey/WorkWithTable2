{"ast":null,"code":"import { defaultColumn, emptyRenderer } from './publicUtils'; // Find the depth of the columns\n\nexport function findMaxDepth(columns) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return columns.reduce((prev, curr) => {\n    if (curr.columns) {\n      return Math.max(prev, findMaxDepth(curr.columns, depth + 1));\n    }\n\n    return depth;\n  }, 0);\n} // Build the visible columns, headers and flat column list\n\nexport function linkColumnStructure(columns, parent) {\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return columns.map(column => {\n    column = { ...column,\n      parent,\n      depth\n    };\n    assignColumnAccessor(column);\n\n    if (column.columns) {\n      column.columns = linkColumnStructure(column.columns, column, depth + 1);\n    }\n\n    return column;\n  });\n}\nexport function flattenColumns(columns) {\n  return flattenBy(columns, 'columns');\n}\nexport function assignColumnAccessor(column) {\n  // First check for string accessor\n  let {\n    id,\n    accessor,\n    Header\n  } = column;\n\n  if (typeof accessor === 'string') {\n    id = id || accessor;\n    const accessorPath = accessor.split('.');\n\n    accessor = row => getBy(row, accessorPath);\n  }\n\n  if (!id && typeof Header === 'string' && Header) {\n    id = Header;\n  }\n\n  if (!id && column.columns) {\n    console.error(column);\n    throw new Error('A column ID (or unique \"Header\" value) is required!');\n  }\n\n  if (!id) {\n    console.error(column);\n    throw new Error('A column ID (or string accessor) is required!');\n  }\n\n  Object.assign(column, {\n    id,\n    accessor\n  });\n  return column;\n}\nexport function decorateColumn(column, userDefaultColumn) {\n  if (!userDefaultColumn) {\n    throw new Error();\n  }\n\n  Object.assign(column, {\n    // Make sure there is a fallback header, just in case\n    Header: emptyRenderer,\n    Footer: emptyRenderer,\n    ...defaultColumn,\n    ...userDefaultColumn,\n    ...column\n  });\n  Object.assign(column, {\n    originalWidth: column.width\n  });\n  return column;\n} // Build the header groups from the bottom up\n\nexport function makeHeaderGroups(allColumns, defaultColumn) {\n  let additionalHeaderProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => ({});\n  const headerGroups = [];\n  let scanColumns = allColumns;\n  let uid = 0;\n\n  const getUID = () => uid++;\n\n  while (scanColumns.length) {\n    // The header group we are creating\n    const headerGroup = {\n      headers: []\n    }; // The parent columns we're going to scan next\n\n    const parentColumns = [];\n    const hasParents = scanColumns.some(d => d.parent); // Scan each column for parents\n\n    scanColumns.forEach(column => {\n      // What is the latest (last) parent column?\n      let latestParentColumn = [...parentColumns].reverse()[0];\n      let newParent;\n\n      if (hasParents) {\n        // If the column has a parent, add it if necessary\n        if (column.parent) {\n          newParent = { ...column.parent,\n            originalId: column.parent.id,\n            id: `${column.parent.id}_${getUID()}`,\n            headers: [column],\n            ...additionalHeaderProperties(column)\n          };\n        } else {\n          // If other columns have parents, we'll need to add a place holder if necessary\n          const originalId = `${column.id}_placeholder`;\n          newParent = decorateColumn({\n            originalId,\n            id: `${column.id}_placeholder_${getUID()}`,\n            placeholderOf: column,\n            headers: [column],\n            ...additionalHeaderProperties(column)\n          }, defaultColumn);\n        } // If the resulting parent columns are the same, just add\n        // the column and increment the header span\n\n\n        if (latestParentColumn && latestParentColumn.originalId === newParent.originalId) {\n          latestParentColumn.headers.push(column);\n        } else {\n          parentColumns.push(newParent);\n        }\n      }\n\n      headerGroup.headers.push(column);\n    });\n    headerGroups.push(headerGroup); // Start scanning the parent columns\n\n    scanColumns = parentColumns;\n  }\n\n  return headerGroups.reverse();\n}\nconst pathObjCache = new Map();\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj;\n  }\n\n  const cacheKey = typeof path === 'function' ? path : JSON.stringify(path);\n\n  const pathObj = pathObjCache.get(cacheKey) || (() => {\n    const pathObj = makePathArray(path);\n    pathObjCache.set(cacheKey, pathObj);\n    return pathObj;\n  })();\n\n  let val;\n\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj);\n  } catch (e) {// continue regardless of error\n  }\n\n  return typeof val !== 'undefined' ? val : def;\n}\nexport function getFirstDefined() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i];\n    }\n  }\n}\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect();\n  const style = window.getComputedStyle(element);\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight)\n  };\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight)\n  };\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(rect.width + margins.left + margins.right + padding.left + padding.right),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth\n  };\n}\nexport function isFunction(a) {\n  if (typeof a === 'function') {\n    return a;\n  }\n}\nexport function flattenBy(arr, key) {\n  const flat = [];\n\n  const recurse = arr => {\n    arr.forEach(d => {\n      if (!d[key]) {\n        flat.push(d);\n      } else {\n        recurse(d[key]);\n      }\n    });\n  };\n\n  recurse(arr);\n  return flat;\n}\nexport function expandRows(rows, _ref) {\n  let {\n    manualExpandedKey,\n    expanded,\n    expandSubRows = true\n  } = _ref;\n  const expandedRows = [];\n\n  const handleRow = function (row) {\n    let addToExpandedRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    row.isExpanded = row.original && row.original[manualExpandedKey] || expanded[row.id];\n    row.canExpand = row.subRows && !!row.subRows.length;\n\n    if (addToExpandedRows) {\n      expandedRows.push(row);\n    }\n\n    if (row.subRows && row.subRows.length && row.isExpanded) {\n      row.subRows.forEach(row => handleRow(row, expandSubRows));\n    }\n  };\n\n  rows.forEach(row => handleRow(row));\n  return expandedRows;\n}\nexport function getFilterMethod(filter, userFilterTypes, filterTypes) {\n  return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;\n}\nexport function shouldAutoRemoveFilter(autoRemove, value, column) {\n  return autoRemove ? autoRemove(value, column) : typeof value === 'undefined';\n}\nexport function unpreparedAccessWarning() {\n  throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');\n}\nlet passiveSupported = null;\nexport function passiveEventSupported() {\n  // memoize support to avoid adding multiple test events\n  if (typeof passiveSupported === 'boolean') return passiveSupported;\n  let supported = false;\n\n  try {\n    const options = {\n      get passive() {\n        supported = true;\n        return false;\n      }\n\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (err) {\n    supported = false;\n  }\n\n  passiveSupported = supported;\n  return passiveSupported;\n} //\n\nconst reOpenBracket = /\\[/g;\nconst reCloseBracket = /\\]/g;\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj) // remove all periods in parts\n  .map(d => String(d).replace('.', '_')) // join parts using period\n  .join('.') // replace brackets with periods\n  .replace(reOpenBracket, '.').replace(reCloseBracket, '') // split it back out on periods\n  .split('.');\n}\n\nfunction flattenDeep(arr) {\n  let newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!Array.isArray(arr)) {\n    newArr.push(arr);\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr);\n    }\n  }\n\n  return newArr;\n}","map":{"version":3,"sources":["C:/Projects/TableSite/tablesite2/node_modules/react-table/src/utils.js"],"names":["defaultColumn","emptyRenderer","findMaxDepth","columns","depth","reduce","prev","curr","Math","max","linkColumnStructure","parent","map","column","assignColumnAccessor","flattenColumns","flattenBy","id","accessor","Header","accessorPath","split","row","getBy","console","error","Error","Object","assign","decorateColumn","userDefaultColumn","Footer","originalWidth","width","makeHeaderGroups","allColumns","additionalHeaderProperties","headerGroups","scanColumns","uid","getUID","length","headerGroup","headers","parentColumns","hasParents","some","d","forEach","latestParentColumn","reverse","newParent","originalId","placeholderOf","push","pathObjCache","Map","obj","path","def","cacheKey","JSON","stringify","pathObj","get","makePathArray","set","val","cursor","pathPart","e","getFirstDefined","args","i","getElementDimensions","element","rect","getBoundingClientRect","style","window","getComputedStyle","margins","left","parseInt","marginLeft","right","marginRight","padding","paddingLeft","paddingRight","ceil","outerWidth","scrollWidth","isFunction","a","arr","key","flat","recurse","expandRows","rows","manualExpandedKey","expanded","expandSubRows","expandedRows","handleRow","addToExpandedRows","isExpanded","original","canExpand","subRows","getFilterMethod","filter","userFilterTypes","filterTypes","text","shouldAutoRemoveFilter","autoRemove","value","unpreparedAccessWarning","passiveSupported","passiveEventSupported","supported","options","passive","addEventListener","removeEventListener","err","reOpenBracket","reCloseBracket","flattenDeep","String","replace","join","newArr","Array","isArray"],"mappings":"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","sourcesContent":["import { defaultColumn, emptyRenderer } from './publicUtils'\n\n// Find the depth of the columns\nexport function findMaxDepth(columns, depth = 0) {\n  return columns.reduce((prev, curr) => {\n    if (curr.columns) {\n      return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n\n// Build the visible columns, headers and flat column list\nexport function linkColumnStructure(columns, parent, depth = 0) {\n  return columns.map(column => {\n    column = {\n      ...column,\n      parent,\n      depth,\n    }\n\n    assignColumnAccessor(column)\n\n    if (column.columns) {\n      column.columns = linkColumnStructure(column.columns, column, depth + 1)\n    }\n    return column\n  })\n}\n\nexport function flattenColumns(columns) {\n  return flattenBy(columns, 'columns')\n}\n\nexport function assignColumnAccessor(column) {\n  // First check for string accessor\n  let { id, accessor, Header } = column\n\n  if (typeof accessor === 'string') {\n    id = id || accessor\n    const accessorPath = accessor.split('.')\n    accessor = row => getBy(row, accessorPath)\n  }\n\n  if (!id && typeof Header === 'string' && Header) {\n    id = Header\n  }\n\n  if (!id && column.columns) {\n    console.error(column)\n    throw new Error('A column ID (or unique \"Header\" value) is required!')\n  }\n\n  if (!id) {\n    console.error(column)\n    throw new Error('A column ID (or string accessor) is required!')\n  }\n\n  Object.assign(column, {\n    id,\n    accessor,\n  })\n\n  return column\n}\n\nexport function decorateColumn(column, userDefaultColumn) {\n  if (!userDefaultColumn) {\n    throw new Error()\n  }\n  Object.assign(column, {\n    // Make sure there is a fallback header, just in case\n    Header: emptyRenderer,\n    Footer: emptyRenderer,\n    ...defaultColumn,\n    ...userDefaultColumn,\n    ...column,\n  })\n\n  Object.assign(column, {\n    originalWidth: column.width,\n  })\n\n  return column\n}\n\n// Build the header groups from the bottom up\nexport function makeHeaderGroups(\n  allColumns,\n  defaultColumn,\n  additionalHeaderProperties = () => ({})\n) {\n  const headerGroups = []\n\n  let scanColumns = allColumns\n\n  let uid = 0\n  const getUID = () => uid++\n\n  while (scanColumns.length) {\n    // The header group we are creating\n    const headerGroup = {\n      headers: [],\n    }\n\n    // The parent columns we're going to scan next\n    const parentColumns = []\n\n    const hasParents = scanColumns.some(d => d.parent)\n\n    // Scan each column for parents\n    scanColumns.forEach(column => {\n      // What is the latest (last) parent column?\n      let latestParentColumn = [...parentColumns].reverse()[0]\n\n      let newParent\n\n      if (hasParents) {\n        // If the column has a parent, add it if necessary\n        if (column.parent) {\n          newParent = {\n            ...column.parent,\n            originalId: column.parent.id,\n            id: `${column.parent.id}_${getUID()}`,\n            headers: [column],\n            ...additionalHeaderProperties(column),\n          }\n        } else {\n          // If other columns have parents, we'll need to add a place holder if necessary\n          const originalId = `${column.id}_placeholder`\n          newParent = decorateColumn(\n            {\n              originalId,\n              id: `${column.id}_placeholder_${getUID()}`,\n              placeholderOf: column,\n              headers: [column],\n              ...additionalHeaderProperties(column),\n            },\n            defaultColumn\n          )\n        }\n\n        // If the resulting parent columns are the same, just add\n        // the column and increment the header span\n        if (\n          latestParentColumn &&\n          latestParentColumn.originalId === newParent.originalId\n        ) {\n          latestParentColumn.headers.push(column)\n        } else {\n          parentColumns.push(newParent)\n        }\n      }\n\n      headerGroup.headers.push(column)\n    })\n\n    headerGroups.push(headerGroup)\n\n    // Start scanning the parent columns\n    scanColumns = parentColumns\n  }\n\n  return headerGroups.reverse()\n}\n\nconst pathObjCache = new Map()\n\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj\n  }\n  const cacheKey = typeof path === 'function' ? path : JSON.stringify(path)\n\n  const pathObj =\n    pathObjCache.get(cacheKey) ||\n    (() => {\n      const pathObj = makePathArray(path)\n      pathObjCache.set(cacheKey, pathObj)\n      return pathObj\n    })()\n\n  let val\n\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\n  } catch (e) {\n    // continue regardless of error\n  }\n  return typeof val !== 'undefined' ? val : def\n}\n\nexport function getFirstDefined(...args) {\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i]\n    }\n  }\n}\n\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect()\n  const style = window.getComputedStyle(element)\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight),\n  }\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight),\n  }\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(\n      rect.width + margins.left + margins.right + padding.left + padding.right\n    ),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth,\n  }\n}\n\nexport function isFunction(a) {\n  if (typeof a === 'function') {\n    return a\n  }\n}\n\nexport function flattenBy(arr, key) {\n  const flat = []\n\n  const recurse = arr => {\n    arr.forEach(d => {\n      if (!d[key]) {\n        flat.push(d)\n      } else {\n        recurse(d[key])\n      }\n    })\n  }\n\n  recurse(arr)\n\n  return flat\n}\n\nexport function expandRows(\n  rows,\n  { manualExpandedKey, expanded, expandSubRows = true }\n) {\n  const expandedRows = []\n\n  const handleRow = (row, addToExpandedRows = true) => {\n    row.isExpanded =\n      (row.original && row.original[manualExpandedKey]) || expanded[row.id]\n\n    row.canExpand = row.subRows && !!row.subRows.length\n\n    if (addToExpandedRows) {\n      expandedRows.push(row)\n    }\n\n    if (row.subRows && row.subRows.length && row.isExpanded) {\n      row.subRows.forEach(row => handleRow(row, expandSubRows))\n    }\n  }\n\n  rows.forEach(row => handleRow(row))\n\n  return expandedRows\n}\n\nexport function getFilterMethod(filter, userFilterTypes, filterTypes) {\n  return (\n    isFunction(filter) ||\n    userFilterTypes[filter] ||\n    filterTypes[filter] ||\n    filterTypes.text\n  )\n}\n\nexport function shouldAutoRemoveFilter(autoRemove, value, column) {\n  return autoRemove ? autoRemove(value, column) : typeof value === 'undefined'\n}\n\nexport function unpreparedAccessWarning() {\n  throw new Error(\n    'React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.'\n  )\n}\n\nlet passiveSupported = null\nexport function passiveEventSupported() {\n  // memoize support to avoid adding multiple test events\n  if (typeof passiveSupported === 'boolean') return passiveSupported\n\n  let supported = false\n  try {\n    const options = {\n      get passive() {\n        supported = true\n        return false\n      },\n    }\n\n    window.addEventListener('test', null, options)\n    window.removeEventListener('test', null, options)\n  } catch (err) {\n    supported = false\n  }\n  passiveSupported = supported\n  return passiveSupported\n}\n\n//\n\nconst reOpenBracket = /\\[/g\nconst reCloseBracket = /\\]/g\n\nfunction makePathArray(obj) {\n  return (\n    flattenDeep(obj)\n      // remove all periods in parts\n      .map(d => String(d).replace('.', '_'))\n      // join parts using period\n      .join('.')\n      // replace brackets with periods\n      .replace(reOpenBracket, '.')\n      .replace(reCloseBracket, '')\n      // split it back out on periods\n      .split('.')\n  )\n}\n\nfunction flattenDeep(arr, newArr = []) {\n  if (!Array.isArray(arr)) {\n    newArr.push(arr)\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr)\n    }\n  }\n  return newArr\n}\n"]},"metadata":{},"sourceType":"module"}